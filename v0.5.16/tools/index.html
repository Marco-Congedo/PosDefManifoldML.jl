<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tools ¬∑ PosDefManifoldML</title><meta name="title" content="Tools ¬∑ PosDefManifoldML"/><meta property="og:title" content="Tools ¬∑ PosDefManifoldML"/><meta property="twitter:title" content="Tools ¬∑ PosDefManifoldML"/><meta name="description" content="Documentation for PosDefManifoldML."/><meta property="og:description" content="Documentation for PosDefManifoldML."/><meta property="twitter:description" content="Documentation for PosDefManifoldML."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="PosDefManifoldML logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PosDefManifoldML</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">PosDefManifoldML Documentation</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../MainModule/">Main Module</a></li><li class="is-active"><a class="tocitem" href>Tools</a><ul class="internal"><li><a class="tocitem" href="#Content"><span>Content</span></a></li></ul></li><li><span class="tocitem">ML Models: PD Manifold</span><ul><li><a class="tocitem" href="../mdm/">Minimum Distance to Mean</a></li></ul></li><li><span class="tocitem">ML Models: PD Tangent Space</span><ul><li><a class="tocitem" href="../enlr/">Elastic-Net Logistic Regression</a></li><li><a class="tocitem" href="../svm/">Support-Vector Machine</a></li></ul></li><li><a class="tocitem" href="../cv/">Fit, Predict, CV</a></li><li><span class="tocitem">Statistics</span><ul><li><a class="tocitem" href="../stats_descriptive/">Descriptive</a></li><li><a class="tocitem" href="../stats_inferential/">Inferential</a></li></ul></li><li><a class="tocitem" href="../conditioners/">Conditioners &amp; Pipelines</a></li><li><a class="tocitem" href="../contribute/">How to contribute</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tools</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tools</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="..." title="View the repository"><span class="docs-icon fa-brands">Ô°Å</span><span class="docs-label is-hidden-touch">Repository</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="tools.jl"><a class="docs-heading-anchor" href="#tools.jl">tools.jl</a><a id="tools.jl-1"></a><a class="docs-heading-anchor-permalink" href="#tools.jl" title="Permalink"></a></h1><p>This unit implements tools that are useful for building Riemannian and Euclidean machine learning classifiers. For basic usage of the package  you won&#39;t need these functions.</p><h2 id="Content"><a class="docs-heading-anchor" href="#Content">Content</a><a id="Content-1"></a><a class="docs-heading-anchor-permalink" href="#Content" title="Permalink"></a></h2><table><tr><th style="text-align: left">function</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.tsMap"><code>tsMap</code></a></td><td style="text-align: left">project data on a tangent space to apply Euclidean ML models therein</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.tsWeights"><code>tsWeights</code></a></td><td style="text-align: left">generate weights for tagent space mapping</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.gen2ClassData"><code>gen2ClassData</code></a></td><td style="text-align: left">generate 2-class positive definite matrix data for testing Riemannian ML models</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.rescale!"><code>rescale!</code></a></td><td style="text-align: left">rescale the rows or columns of a real matrix to be in range [a, b]</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.demean!"><code>demean!</code></a></td><td style="text-align: left">remove the mean of the rows or columns of a real matrix</td></tr><tr><td style="text-align: left"><a href="#LinearAlgebra.normalize!"><code>normalize!</code></a></td><td style="text-align: left">normalize the rows or columns of a real matrix</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.standardize!"><code>standardize!</code></a></td><td style="text-align: left">standardize the rows or columns of a real matrix</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.saveas"><code>saveas</code></a></td><td style="text-align: left">save a whatever object to a file</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.load"><code>load</code></a></td><td style="text-align: left">load a whatever object from a file</td></tr></table><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifoldML.tsMap" href="#PosDefManifoldML.tsMap"><code>PosDefManifoldML.tsMap</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function tsMap(	metric :: Metric, ùêè :: ‚ÑçVector;
    w           :: Vector = Float64[],
    ‚úìw         :: Bool = true,
    ‚è©          :: Bool = true,
    meanISR     :: Union{‚Ñç, Nothing, UniformScaling}  = nothing,
    meanInit    :: Union{‚Ñç, Nothing}  = nothing,
    tol         :: Real = 0.,
    transpose   :: Bool = true,
    vecRange    :: UnitRange = 1:size(ùêè[1], 1))</code></pre><p>The <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/riemannianGeometry/#PosDefManifold.logMap">tangent space mapping</a> of positive definite matrices <span>$P_i$</span>, <em>i=1...k</em> with mean <em>G</em>, once those points have been parallel transported to the identity matrix, is given by:</p><p><span>$S_i=\textrm{log}(G^{-1/2} P_i G^{-1/2})$</span>.</p><p>Given a vector of <em>k</em> matrices <code>ùêè</code> flagged by julia as <code>Hermitian</code>, return a matrix <em>X</em> with such tangent vectors of the matrices in <code>ùêè</code> vectorized as per the <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/riemannianGeometry/#PosDefManifold.vecP">vecP</a> operation.</p><p>The mean <em>G</em> of the matrices in <code>ùêè</code> is found according to the specified <code>metric</code>, of type <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#Metric::Enumerated-type-1">Metric</a>. A natural choice is the <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/introToRiemannianGeometry/#Fisher-1">Fisher metric</a>. If the metric is Fisher, logdet0 or Wasserstein the mean is found with an iterative algorithm with tolerance given by optional keyword argument <code>tol</code>. By default <code>tol</code> is set by the function <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/riemannianGeometry/#Statistics.mean">mean</a>. For those iterative algorithms a particular initialization can be provided as an Hermitian matrix by optional keyword argument <code>meanInit</code>.</p><p>A set of <em>k</em> optional non-negative weights <code>w</code> can be provided for computing a weighted mean <em>G</em>, for any metrics. If <code>w</code> is non-empty and optional keyword argument <code>‚úìw</code> is true (default), the weights are normalized so as to sum up to 1, otherwise they are used as they are passed and should be already normalized. This option is provided to allow calling this function repeatedly without normalizing the same weights vector each time.</p><p>If an Hermitian matrix is provided as optional keyword argument <code>meanISR</code>, then the mean <em>G</em> is not computed, intead this matrix is used directly in the formula as the inverse square root (ISR) <span>$G^{-1/2}$</span>. If <code>meanISR</code> is provided, arguments <code>tol</code> and <code>meanInit</code> have no effect whatsoever.</p><p>If <code>meanISR=I</code> is used, then the tangent space mapping is obtained  at the identity matrix as</p><p><span>$S_i=\textrm{log}(P_i)$</span>.</p><p>This corresponds to the tangent space mapping adopting the log-Euclidean metric. It is also useful when the data has been already recentered, for example by means of a <a href="../conditioners/#PosDefManifoldML.Recenter"><code>Recenter</code></a> pre-conditioner. If <code>meanISR=I</code> is used, arguments  <code>w</code>, <code>‚úìw</code>, <code>meanInit</code>, and <code>tol</code> are ignored.</p><p>If <code>meanISR</code> is not provided, return the 2-tuple <span>$(X, G^{-1/2})$</span>, otherwise return only matrix <em>X</em>.</p><p>If an <code>UnitRange</code> is provided with the optional keyword argument <code>vecRange</code>, the vectorization concerns only the columns (or rows) of the matrices <code>ùêè</code> specified by the range.</p><p>If optional keyword argument <code>transpose</code> is true (default), <em>X</em> holds the <em>k</em> vectorized tangent vectors in its rows, otherwise they are arranged in its columns. The dimension of the rows in the former case and of the columns is the latter case is <em>n(n+1)√∑2</em> (integer division), where <em>n</em> is the size of the matrices in <code>ùêè</code>, unless a <code>vecRange</code> spanning a subset of the columns or rows of the matrices in <code>ùêè</code> has been provided, in which case the dimension will be smaller. (see <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/riemannianGeometry/#PosDefManifold.vecP">vecP</a> ).</p><p>if optional keyword argument <code>‚è©</code> if true (default), the computation of the mean and the projection on the tangent space are multi-threaded. Multi-threading is automatically disabled if the number of threads Julia is instructed to use is <em>&lt;2</em> or <em>&lt;2k</em>.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">using PosDefManifoldML

# generate four random symmetric positive definite 3x3 matrices
Pset = randP(3, 4)

# project and vectorize in the tangent space
X, G‚Åª¬Ω = tsMap(Fisher, Pset)

# X is a 4x6 matrix, where 6 is the size of the
# vectorized tangent vectors (n=3, n*(n+1)/2=6)

# If repeated calls have to be done, faster computations are obtained
# providing the inverse square root of the matrices in Pset, e.g.,
X1 = tsMap(Fisher, ‚ÑçVector(Pset[1:2]); meanISR = G‚Åª¬Ω)
X2 = tsMap(Fisher, ‚ÑçVector(Pset[3:4]); meanISR = G‚Åª¬Ω)</code></pre><p><strong>See</strong>: <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#%E2%84%8DVector-type-1">the ‚ÑçVector type</a>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifoldML.tsWeights" href="#PosDefManifoldML.tsWeights"><code>PosDefManifoldML.tsWeights</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function tsWeights(y::Vector{Int}; classWeights=[])</code></pre><p>Given an <a href="../MainModule/#IntVector">IntVector</a> of labels <code>y</code>, return a vector of weights summing up to 1 such that the overall weight is the same for all classes (balancing). This is useful for machine learning models in the tangent space with unbalanced classes for computing the mean, that is, the base point to map PD matrices onto the tangent space. For this mapping, giving equal weights to all observations actually overweights the larger classes and downweight the smaller classes.</p><p>Class labels for <em>n</em> classes must be the first <em>n</em> natural numbers, that is, <code>1</code> for class 1, <code>2</code> for class 2, etc. The labels in <code>y</code> can be provided in any order.</p><p>if a vector of <em>n</em> weights is specified as optional keyword argument <code>classWeights</code>, the overall weights for each class will be first balanced (see here above), then weighted by the <code>classWeights</code>. This allow user-defined control of weighting independently from the number of observations in each class. The weights in <code>classWeights</code> can be any integer or real non-negative numbers. The returned weight vector will nonetheless sum up to 1.</p><p>When you invoke the <a href="../cv/#StatsAPI.fit"><code>fit</code></a> function for tangent space models you don&#39;t actually need this function, as you can invoke it implicitly passing symbol <code>:balanced</code> (or just <code>:b</code>) or a tuple with the class weights as optional keyword argument <code>w</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># generate some data; the classes are unbalanced
PTr, PTe, yTr, yTe=gen2ClassData(10, 30, 40, 60, 80, 0.1)

# Fit an ENLR lasso model and find the best model by cross-validation
# balancing the weights for tangent space mapping
m=fit(ENLR(), PTr, yTr; w=tsWeights(yTr))

# A simpler syntax is
m=fit(ENLR(), PTr, yTr; w=:balanced)

# to balance the weights and then give overall weight 0.5 to class 1
# and 1.5 to class 2:
m=fit(ENLR(), PTr, yTr; w=(0.5, 1.5))

# which is equivalent to
m=fit(ENLR(), PTr, yTr; w=tsWeights(yTr; classWeights=(0.5, 1.5)))
</code></pre><p>This is how it works:</p><pre><code class="language-julia hljs">using PosDefManifoldML

# Suppose these are the labels:

y=[1, 1, 1, 1, 2, 2]

# We want the four observations of class 1 to count as much
# as the two observations of class 2.

tsWeights(y)

# 6-element Array{Float64,1}:
# 0.125
# 0.125
# 0.125
# 0.125
# 0.25
# 0.25

# i.e., 0.125*4 = 1.25*2
# and all weights sum up to 1

# Now, suppose we want to give to class 2 a weight
# four times bigger as compared to class 1:

tsWeights(y, classWeights=[1, 4])

# 6-element Array{Float64,1}:
# 0.05
# 0.05
# 0.05
# 0.05
# 0.4
# 0.4

# and, again, all weights sum up to 1.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifoldML.gen2ClassData" href="#PosDefManifoldML.gen2ClassData"><code>PosDefManifoldML.gen2ClassData</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function gen2ClassData(n        ::  Int,
                       k1train  ::  Int,
                       k2train  ::  Int,
                       k1test   ::  Int,
                       k2test   ::  Int,
                       separation :: Real = 0.1)</code></pre><p>Generate for two classes (1 and 2) a random <em>training set</em> holding <code>k1train</code>+<code>k2train</code> and a random <em>test set</em> holding <code>k1test</code>+<code>k2test</code> symmetric positive definite matrices. All matrices have size <em>n</em>x<em>n</em>.</p><p>The training and test sets can be used to train and test any <a href="../MainModule/#MLmodel">MLmodel</a>.</p><p><code>separation</code> is a coefficient determining how well the two classs are separable; the higher it is, the more separable the two classes are. It must be in <span>$[0, 1]$</span> and typically a value of 0.5 already determines complete separation.</p><p>Return a 4-tuple with</p><ul><li>an <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#%E2%84%8DVector-type-1">‚ÑçVector</a> holding the <code>k1train</code>+<code>k2train</code> matrices in the training set,</li><li>an ‚ÑçVector holding the <code>k1test</code>+<code>k2test</code> matrices in the test set,</li><li>a vector holding the <code>k1train</code>+<code>k2train</code> labels (integers) corresponding to the matrices of the training set,</li><li>a vector holding the <code>k1test</code>+<code>k2test</code> labels corresponding to the matrices of the test set (<em>1</em> for class 1 and <em>2</em> for class 2).</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifoldML

PTr, PTe, yTr, yTe=gen2ClassData(10, 30, 40, 60, 80, 0.25)

# PTr=training set: 30 matrices for class 1 and 40 matrices for class 2
# PTe=testing set: 60 matrices for class 1 and 80 matrices for class 2
# all matrices are 10x10
# yTr=a vector of 70 labels for the training set
# yTe=a vector of 140 labels for the testing set
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifoldML.rescale!" href="#PosDefManifoldML.rescale!"><code>PosDefManifoldML.rescale!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function rescale!(X::Matrix{T},	bounds::Tuple=(-1, 1);
		dims::Int=1) where T&lt;:Real</code></pre><p>Rescale the columns or the rows of real matrix <code>X</code> to be in range [a, b], where a and b are the first and seconf elements of tuple <code>bounds</code>.</p><p>By default it applies to the columns. Use <code>dims=2</code> for rescaling the rows.</p><p>This function is used for normalizing tangent space (feature) vectors. Typically, you won&#39;t need it. When fitting a model with <a href="../cv/#StatsAPI.fit"><code>fit</code></a>  or performing a cross-validation with <a href="../cv/#PosDefManifoldML.crval"><code>crval</code></a>, you can simply pass <code>bounds</code> to the argument <code>rescale</code> of these functions.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifoldML.demean!" href="#PosDefManifoldML.demean!"><code>PosDefManifoldML.demean!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function demean!(X::Matrix{T}; dims::Int=1) where T&lt;:Real </code></pre><p>Remove the mean from the columns or from the rows of real matrix <code>X</code>.</p><p>By default it applies to the columns. Use <code>dims=2</code> for demeaning the rows.</p><p>This function is used for normalizing tangent space (feature) vectors. Typically, you won&#39;t need it. When fitting a model with <a href="../cv/#StatsAPI.fit"><code>fit</code></a>  or performing a cross-validation with <a href="../cv/#PosDefManifoldML.crval"><code>crval</code></a>, you can simply pass this function as the <code>normalize</code> argument.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.normalize!" href="#LinearAlgebra.normalize!"><code>LinearAlgebra.normalize!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function normalize!(X::Matrix{T}; dims::Int=1) where T&lt;:Real </code></pre><p>Normalize the columns or the rows of real matrix <code>X</code> so that their 2-norm divided by their number of elements is 1.0. This way the value of each element of matrix <code>X</code> gravitates  around 1.0, regardless its size.</p><p>By default it applies to the columns. Use <code>dims=2</code> for normlizing the rows.</p><p>This function is used for normalizing tangent space (feature) vectors. Typically, you won&#39;t need it. When fitting a model with <a href="../cv/#StatsAPI.fit"><code>fit</code></a>  or performing a cross-validation with <a href="../cv/#PosDefManifoldML.crval"><code>crval</code></a>, you can simply pass this function as the <code>normalize</code> argument.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifoldML.standardize!" href="#PosDefManifoldML.standardize!"><code>PosDefManifoldML.standardize!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function standardize!(X::Matrix{T}; dims::Int=1) where T&lt;:Real </code></pre><p>Standardize the columns or the rows of real matrix <code>X</code> so that they have zero mean and unit (uncorrected) standard deviation.</p><p>By default it applies to the columns. Use <code>dims=2</code> for standardizing the rows.</p><p>This function is used for normalizing tangent space (feature) vectors. Typically, you won&#39;t need it. When fitting a model with <a href="../cv/#StatsAPI.fit"><code>fit</code></a>  or performing a cross-validation with <a href="../cv/#PosDefManifoldML.crval"><code>crval</code></a>, you can simply pass this function as the <code>normalize</code> argument.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifoldML.saveas" href="#PosDefManifoldML.saveas"><code>PosDefManifoldML.saveas</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    function saveas(object, filename::String)</code></pre><p>Save the <code>object</code> to a file, which full path is given as <code>filemane</code>. It can be used, for instance, to save <a href="../cv/#PosDefManifoldML.CVres"><code>CVres</code></a> structures and <a href="../conditioners/#PosDefManifoldML.Pipeline"><code>Pipeline</code></a> tuples.</p><p><strong>See</strong>: <a href="#PosDefManifoldML.load"><code>load</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifoldML, PosDefManifold, Serialization

## Save and then load a cross-validation structure

P, _dummyP, y, _dummyy = gen2ClassData(10, 40, 40, 30, 40, 0.15)

cv = crval(MDM(logEuclidean), P, y; scoring=:a)

filename=joinpath(@__DIR__, &quot;mycv.jls&quot;)
saveas(cv, filename)

mycv = load(filename)

# retrive the p-value of the cross-validation
mycv.p

## Save and then load a pipeline

# Generate some &#39;training&#39; and `test` data
PTr=randP(3, 20) # 20 random 3x3 Hermitian matrices
PTe=randP(3, 5) # 5 random 3x3 Hermitian matrices

# fit a pipeline and transform the training data
p = fit!(PTr, @pipeline Recenter(; eVar=0.99) Compress)

# save the fitted pipeline
filename=joinpath(@__DIR__, &quot;pipeline.jls&quot;)
saveas(p, filename) 

mypipeline = load(filename)

# transform the testing data using the loaded pipeline
transform!(PTe, mypipeline)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifoldML.load" href="#PosDefManifoldML.load"><code>PosDefManifoldML.load</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    function load(filename::String)</code></pre><p>Load and retur an <code>object</code> stored to a file,  which full path is given as <code>filemane</code>.</p><p>It can be used, for instance, to load <a href="../cv/#PosDefManifoldML.CVres"><code>CVres</code></a> structures and <a href="../conditioners/#PosDefManifoldML.Pipeline"><code>Pipeline</code></a> tuples.</p><p>For pipelines, there is no check that it matches the dimension of the data  to which it will be applied. This is the user&#39;s responsibility.</p><p><strong>See</strong> <a href="#PosDefManifoldML.saveas"><code>saveas</code></a></p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../MainModule/">¬´ Main Module</a><a class="docs-footer-nextpage" href="../mdm/">Minimum Distance to Mean ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Wednesday 24 December 2025 16:31">Wednesday 24 December 2025</span>. Using Julia version 1.11.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

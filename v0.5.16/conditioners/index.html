<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Conditioners &amp; Pipelines ¬∑ PosDefManifoldML</title><meta name="title" content="Conditioners &amp; Pipelines ¬∑ PosDefManifoldML"/><meta property="og:title" content="Conditioners &amp; Pipelines ¬∑ PosDefManifoldML"/><meta property="twitter:title" content="Conditioners &amp; Pipelines ¬∑ PosDefManifoldML"/><meta name="description" content="Documentation for PosDefManifoldML."/><meta property="og:description" content="Documentation for PosDefManifoldML."/><meta property="twitter:description" content="Documentation for PosDefManifoldML."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="PosDefManifoldML logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PosDefManifoldML</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">PosDefManifoldML Documentation</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../MainModule/">Main Module</a></li><li><a class="tocitem" href="../tools/">Tools</a></li><li><span class="tocitem">ML Models: PD Manifold</span><ul><li><a class="tocitem" href="../mdm/">Minimum Distance to Mean</a></li></ul></li><li><span class="tocitem">ML Models: PD Tangent Space</span><ul><li><a class="tocitem" href="../enlr/">Elastic-Net Logistic Regression</a></li><li><a class="tocitem" href="../svm/">Support-Vector Machine</a></li></ul></li><li><a class="tocitem" href="../cv/">Fit, Predict, CV</a></li><li><span class="tocitem">Statistics</span><ul><li><a class="tocitem" href="../stats_descriptive/">Descriptive</a></li><li><a class="tocitem" href="../stats_inferential/">Inferential</a></li></ul></li><li class="is-active"><a class="tocitem" href>Conditioners &amp; Pipelines</a><ul class="internal"><li><a class="tocitem" href="#Conditioners"><span>Conditioners</span></a></li><li><a class="tocitem" href="#Pipelines"><span>Pipelines</span></a></li><li><a class="tocitem" href="#Content"><span>Content</span></a></li></ul></li><li><a class="tocitem" href="../contribute/">How to contribute</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Conditioners &amp; Pipelines</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Conditioners &amp; Pipelines</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="..." title="View the repository"><span class="docs-icon fa-brands">Ô°Å</span><span class="docs-label is-hidden-touch">Repository</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="conditioners.jl"><a class="docs-heading-anchor" href="#conditioners.jl">conditioners.jl</a><a id="conditioners.jl-1"></a><a class="docs-heading-anchor-permalink" href="#conditioners.jl" title="Permalink"></a></h1><p>This unit implements <em>conditioners</em>, also called <em>pre-conditioners</em> and <strong>pipelines</strong>, which are specified sequences of conditioners.</p><p>Pipelines are applied to the data (symmetric positive-definite matrices) in order to increase the classification performance and/or to reduce the computational complexity of classifiers.</p><h2 id="Conditioners"><a class="docs-heading-anchor" href="#Conditioners">Conditioners</a><a id="Conditioners-1"></a><a class="docs-heading-anchor-permalink" href="#Conditioners" title="Permalink"></a></h2><p>The available conditioners are</p><table><tr><th style="text-align: left">Conditioner type</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.Tikhonov"><code>Tikhonov</code></a></td><td style="text-align: left">Tikhonov regularization</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.Recenter"><code>Recenter</code></a></td><td style="text-align: left">Recentering aroung the identity matrix w/o dimensionality reduction</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.Compress"><code>Compress</code></a></td><td style="text-align: left">Global scaling reducing the norm</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.Equalize"><code>Equalize</code></a></td><td style="text-align: left">Individual scaling (normalization) to reduce the norm</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.Shrink"><code>Shrink</code></a></td><td style="text-align: left">Move along the geodesic to reduce the norm</td></tr></table><p>In the table above, as elsewhere in this documentation, by norm of a matrix it is meant the distance of the matrix to the identity.</p><h2 id="Pipelines"><a class="docs-heading-anchor" href="#Pipelines">Pipelines</a><a id="Pipelines-1"></a><a class="docs-heading-anchor-permalink" href="#Pipelines" title="Permalink"></a></h2><p>Pipelines are stored as a dedicated tuple type - see <a href="#PosDefManifoldML.Pipeline"><code>Pipeline</code></a>.</p><h2 id="Content"><a class="docs-heading-anchor" href="#Content">Content</a><a id="Content-1"></a><a class="docs-heading-anchor-permalink" href="#Content" title="Permalink"></a></h2><table><tr><th style="text-align: left">function</th><th style="text-align: left">description</th></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.@pipeline"><code>@pipeline</code></a></td><td style="text-align: left">Macro to create a pipeline</td></tr><tr><td style="text-align: left"><a href="#StatsAPI.fit!"><code>fit!</code></a></td><td style="text-align: left">Fit a pipeline and transform the data</td></tr><tr><td style="text-align: left"><a href="#DataFrames.transform!"><code>transform!</code></a></td><td style="text-align: left">Transform the data using a fitted pipeline</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.pickfirst"><code>pickfirst</code></a></td><td style="text-align: left">Return a copy of a specific conditioner in a pipeline</td></tr><tr><td style="text-align: left"><a href="#PosDefManifoldML.includes"><code>includes</code></a></td><td style="text-align: left">Check whether a conditioner type is in a pipeline</td></tr><tr><td style="text-align: left"><a href="#PosDefManifold.dim"><code>dim</code></a></td><td style="text-align: left">Dimension determined by a recentering pre-conditioner in a pipeline</td></tr></table><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifoldML.Tikhonov" href="#PosDefManifoldML.Tikhonov"><code>PosDefManifoldML.Tikhonov</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct Tikhonov &lt;: Conditioner
    Œ±
    threaded </code></pre><p>Mutable structure for the <strong>Tikhonov regularization</strong> conditioner. </p><p>Given a set of points <span>$ùêè$</span> in the manifold of positive-definite matrices, transform the set such as </p><p><span>$P_j+Œ±I, \ j=1,...,k$</span>,</p><p>where <span>$I$</span> is the identity matrix and <span>$Œ±$</span> is a non-negative scalar.</p><p>This conditioner structure has two fields: </p><ul><li><p><code>.Œ±</code>, which is written in the structure when it is fitted to some data.</p></li><li><p><code>.threaded</code>, to determine if the transformation is done in multi-threading mode (true by default).</p></li></ul><p>For constructing an instance, <code>Œ±</code> is an argument, while <code>threaded</code> is a optional keyword argument. </p><div class="admonition is-warning" id="This-is-not-a-data-driven-conditioner-4fc4422a3747f5b0"><header class="admonition-header">This is not a data-driven conditioner<a class="admonition-anchor" href="#This-is-not-a-data-driven-conditioner-4fc4422a3747f5b0" title="Permalink"></a></header><div class="admonition-body"><p>The <code>Œ±</code> parameter must be given explicitly upon construction (it is zero by default).</p></div></div><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">using PosDefManifoldML, PosDefManifold

# Create a conditioner
T = Tikhonov(0.001)
T = Tikhonov(0.001; threaded=false)</code></pre><p><strong>See also</strong>: <a href="#StatsAPI.fit!"><code>fit!</code></a>, <a href="#DataFrames.transform!"><code>transform!</code></a>, <a href="../cv/#PosDefManifoldML.crval"><code>crval</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifoldML.Recenter" href="#PosDefManifoldML.Recenter"><code>PosDefManifoldML.Recenter</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct Recenter &lt;: Conditioner
    metric 
    eVar 
    w 
    ‚úìw 
    init 
    tol 
    verbose 
    forcediag 
    threaded 
    ## Fitted parameters
    Z 
    iZ </code></pre><p>Mutable structure for the <strong>recentering</strong> conditioner. </p><p>Given a set of <code>n¬∑n</code> points <span>$ùêè$</span> in the manifold of positive-definite matrices, transform the set such as </p><p><span>$ZP_jZ^T, \ j=1,...,k$</span>,</p><p>where <span>$Z$</span> is the whitening matrix of the barycenter of <span>$ùêè$</span> as specified by the conditioner, <em>i.e.</em>, if <span>$G$</span> is the barycenter of <span>$ùêè$</span>, then <span>$ZGZ^T=I$</span>.</p><p>After recentering the barycenter becomes the identity matrix and the mean of the eigenvalues of the whitened matrices is 1. In the manifold of positive-definite matrices, recentering is equivalent to parallel transport of all points to the identity barycenter, according to a given metric.</p><p>Depending on the <code>eVar</code> value used to define the <a href="#PosDefManifoldML.Recenter"><code>Recenter</code></a> conditioner, matrices <span>$Z$</span> may determine a dimensionality reduction of the input points as well. In this case <span>$Z$</span> is not square, but a wide matrix of dimension <span>$p¬∑n$</span>, with <span>$p&lt;n$</span>.</p><p>This conditioner may behave in a <strong>supervised</strong> way; providing the class labels  when it is fitted (see <a href="#StatsAPI.fit!"><code>fit!</code></a>), the classes are equally weighted to compute the barycenter <span>$G$</span>, like <a href="../tools/#PosDefManifoldML.tsWeights"><code>tsWeights</code></a> does for computing the barycenter used for tangent space mapping. If the classes are balanced, the weighting has no effect.</p><p>This conditioner structure has the following fields:</p><ul><li><p><code>.metric</code>, of type  <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#Metric::Enumerated-type-1">Metric</a>, is to be specified by the user. It is the metric that will be adopted to compute the class means and the distances to the mean. default: <code>PosDefManifold.Euclidean</code>.</p></li><li><p><code>.eVar</code>, the desired explained variance for the whitening. It can be a Real, Int or <code>nothing</code>. See the documentation of method <a href="https://marco-congedo.github.io/Diagonalizations.jl/dev/whitening/#Diagonalizations.whitening">whitening</a> in Diagonalizations.jl. It is 0.9999 by default.</p></li><li><p>Fields <code>.w</code>, <code>.‚úìw</code>, <code>.init</code> and <code>.tol</code> are passed to the <a href="https://marco-congedo.github.io/PosDefManifold.jl/latest/riemannianGeometry/#Statistics.mean">mean</a> method of PosDefManifold.jl for computing the barycenter <span>$G$</span>. Refer to the documentation therein for details.</p></li><li><p><code>.verbose</code> is a boolean determining if information is to be printed to the REPL when using <code>fit!</code> and <code>transform!</code> with this conditioner. It is false by default.</p></li><li><p><code>.forcediag</code> is a boolean for forcing diagonalization. It is true by default. If false, whitening is carried out only if a dimensionality reduction is needed, as determined by <code>eVar</code>.</p></li><li><p>If <code>.threaded</code> is true (default), all operations are multi-threaded.</p></li></ul><p>For constructing an instance, <code>metric</code> is an argument, while <code>eVar</code>, <code>w</code>, <code>‚úìw</code>,  <code>init</code>, <code>tol</code>, <code>verbose</code>, <code>forcediag</code> and <code>threaded</code> are optional keyword arguments.</p><p><strong>Fitted parameters</strong></p><p>When the conditioner is fitted, the following fields are written:</p><ul><li><p><code>.Z</code>, the whitening matrix of the fitted set <span>$P_j, \ j=1,...,k$</span>, such that <span>$ZP_jZ^T$</span> is whitened;</p></li><li><p><code>.iZ</code>, the left inverse <span>$Z^*$</span> of Z, such that <span>$Z^*Z=I$</span> (identity matrix) if no dimensionality reduction is operated.</p></li></ul><p>If dimensionality reduction is operated, <span>$Z^*Z‚â†I$</span> has rank <span>$p$</span>.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">using PosDefManifoldML, PosDefManifold

# Create a default conditioner
R = Recenter(PosDefManifold.Euclidean)

# Since the Euclidean metric is the default metric,
# this is equivalent to
R = Recenter()

# Do not perform dimensionality reduction
R = Recenter(PosDefManifold.Fisher; eVar=nothing)

# Reduce the dimension to 10
R = Recenter(PosDefManifold.Fisher; eVar=10)

# Determine the dimension so as to explain at least 90% of the variance
R = Recenter(PosDefManifold.Fisher; eVar=0.9)
</code></pre><p><strong>See also</strong>: <a href="#StatsAPI.fit!"><code>fit!</code></a>, <a href="#DataFrames.transform!"><code>transform!</code></a>, <a href="../cv/#PosDefManifoldML.crval"><code>crval</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifoldML.Compress" href="#PosDefManifoldML.Compress"><code>PosDefManifoldML.Compress</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct Compress &lt;: Conditioner
    threaded
    Œ≤ 
end</code></pre><p>Mutable structure for the <strong>compressing</strong> conditioner.</p><p>Given a set of points <span>$ùêè$</span> in the manifold of positive-definite matrices, transform the set such as </p><p><span>$Œ≤P_j, \ j=1,...,k$</span>,</p><p>where <span>$Œ≤$</span> is chosen to minimize the average Euclidean norm of the transformed set, <em>i.e.</em>, the average distance to the identity matrix according to the specifies metric.</p><p>Since the Euclidean norm is the Euclidean distance to the identity, compressing  a recentered set of points minimizes the average dispersion of the set around  the identity, thus it should be performed after conditioner <a href="#PosDefManifoldML.Recenter"><code>Recenter</code></a>. </p><p>The structure has one field only:</p><ul><li><code>.threaded</code>, determining whether the computations are multi-threaded (true by default).</li></ul><p>For constructing an instance, only the <code>threaded</code> optional keyword argument can be used.</p><p><strong>Fitted parameters</strong></p><p>When the conditioner is fitted, the following field is written:</p><ul><li><code>.Œ≤</code>, a positive scalar minimizing the average Euclidean norm of the fitted set.</li></ul><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">using PosDefManifoldML, PosDefManifold

# Create the conditioner
C = Compress()</code></pre><p><strong>See also</strong>: <a href="#StatsAPI.fit!"><code>fit!</code></a>, <a href="#DataFrames.transform!"><code>transform!</code></a>, <a href="../cv/#PosDefManifoldML.crval"><code>crval</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifoldML.Equalize" href="#PosDefManifoldML.Equalize"><code>PosDefManifoldML.Equalize</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct Equalize &lt;: Conditioner
    threaded
    Œ≤ 
end</code></pre><p>Mutable structure for the <strong>equalizing</strong> conditioner.</p><p>Given a set of points <span>$ùêè$</span> in the manifold of positive-definite matrices, transform the set such as </p><p><span>$Œ≤_jP_j, \ j=1,...,k$</span>,</p><p>where the elements <span>$Œ≤_j$</span> are chosen so as to minimize the Euclidean norm  of the transformed matrices individually.</p><p>Since the Euclidean norm is the Euclidean distance to the identity, equalizing  a recentered set of points minimizes the average dispersion of the set around  the identity, thus it should be performed after conditioner <a href="#PosDefManifoldML.Recenter"><code>Recenter</code></a>. </p><p>As compared to compression, equalization is more effective for reducing the distance  to the identity, however it is not an isometry.</p><p>Also, in contrast to compression, the transformation of the  matrices in set <span>$ùêè$</span> is individual, so fitting equalization does not imply  a learning process - see <a href="#StatsAPI.fit!"><code>fit!</code></a>.</p><p>The structure has one field only:</p><ul><li><code>.threaded</code>, determining whether the computations are multi-threaded (true by default).</li></ul><p>For constructing an instance, only the <code>threaded</code> optional keyword argument can be used.</p><p><strong>Fitted parameters</strong></p><p>When the conditioner is fitted, the following field is written:</p><ul><li><code>.Œ≤</code>, a vector of positive scalars minimizing the Euclidean norm individually for each matrix in the fitted set. </li></ul><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">using PosDefManifoldML, PosDefManifold

# Create the conditioner
E = Equalize()</code></pre><p><strong>See also</strong>: <a href="#StatsAPI.fit!"><code>fit!</code></a>, <a href="#DataFrames.transform!"><code>transform!</code></a>, <a href="../cv/#PosDefManifoldML.crval"><code>crval</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifoldML.Shrink" href="#PosDefManifoldML.Shrink"><code>PosDefManifoldML.Shrink</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct Shrink &lt;: Conditioner
        metric 
        radius 
        refpoint 
        reshape 
        epsilon 
        verbose 
        threaded 
        ## Fitted parameters
        Œ≥ 
        m 
        sd </code></pre><p>Mutable structure of the <strong>geodesic shrinking</strong> conditioner. </p><p>Given a set of points <span>$ùêè$</span> in the manifold of positive-definite matrices, this conditioner moves all points towards or away from the identity matrix <span>$I$</span> along geodesics on the manifold defined in accordance to the specified <code>metric</code>. This effectively defines a ball centered at <span>$I$</span>.</p><p>The step-size <span>$Œ≥$</span> of the geodesics from <span>$I$</span> to each point <span>$P$</span> in <span>$ùêè$</span> is given by</p><p><span>$\gamma=\frac{r\sqrt{n}}{Œ¥(P, I) + œµ}$</span></p><p>where <span>$r$</span> is the <code>radius</code> argument, <span>$n$</span> is the dimension of <span>$P$</span>,  <span>$Œ¥(P, I)$</span> is the norm of <span>$P$</span> according to the specified <code>metric</code> and <span>$œµ$</span> is an optional  small positive number given as argument <code>epsilon</code>.</p><p>The conditioner has the following fields, which are also keyword arguments that can be passed upon construction:</p><p><code>.metric</code>, of type <a href="https://marco-congedo.github.io/PosDefManifold.jl/dev/MainModule/#Metric::Enumerated-type-1">Metric</a>, with default <code>PosDefManifold.Euclidean</code>.</p><p>After shrinking, the set of points <span>$ùêè$</span> acquires a sought <code>.radius</code>,  which is given as optional keyword argument to the constructor (default: 0.02). This is a measure of their acquired distances from the identity (norms),  specifically, the maximum distance if <code>.refpoint</code>=:max or the mean eccentricity  if <code>.refpoint</code>=:mean (default).  In the first case the argument <code>radius</code> defines a ball confining all points, with radius equal to the maximum distance from the identity of the transformed points + <span>$œµ$</span>.  In the second case, the actual radius of the ball is equal to </p><p><span>$\sqrt{\frac{1}{n}\sum_{j=1}^{k}Œ¥(P_j, I) + œµ}$</span>.</p><p><code>.reshape</code>, a boolean for reshaping the eigenvalues of the set <span>$ùêè$</span> after shrinking.  It applies only to the Fisher (affine-invariant) metric. Default: false. See below.</p><p><code>.epsilon</code>, a non-negative real number, the <span>$œµ$</span> above. Default: 0.0.</p><p><code>.verbose</code>, a boolean. If true, information is printed in the REPL. Default: false</p><p><code>.threaded</code>, a boolean for using multi-threading. Default: true</p><p>For constructing an instance, <code>metric</code> is an argument, while <code>radius</code>, <code>refpoint</code>, <code>reshape</code>,  <code>epsilon</code>, <code>verbose</code> and <code>threaded</code> are optional keyword arguments.</p><p><strong>Fitted parameters</strong></p><p>When the conditioner is fitted, the following fields are written:</p><p><code>.Œ≥</code>, the step-size for geodesics (according to <code>metric</code>) from <span>$I$</span> to the each matrix in <span>$ùêè$</span>.</p><p><code>.m</code> and <code>.sd</code>, the mean and standard deviation of the eigenvalues of the set after shrinking. This is used for reshaping, which applies only if the Fisher metric is adopted. Reshaping is meaningful only if the input set has been recentered (see <a href="#PosDefManifoldML.Recenter"><code>Recenter</code></a>). It recenters again the eigenvalues of the set after shrinking (mean = 1),  and normalize them so as to have standard deviation equal to <code>.radius</code>.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia hljs">using PosDefManifoldML, PosDefManifold

# Create a conditioner adopting the Fisher Metric and use reshaping
S = Shrink(PosDefManifold.Fisher; reshape = true)</code></pre><p><strong>See also</strong>: <a href="#StatsAPI.fit!"><code>fit!</code></a>, <a href="#DataFrames.transform!"><code>transform!</code></a>, <a href="../cv/#PosDefManifoldML.crval"><code>crval</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifoldML.Pipeline" href="#PosDefManifoldML.Pipeline"><code>PosDefManifoldML.Pipeline</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>Pipeline</code> is a type for tuples holding conditioners.</p><p>A pipeline holds a sequence of conditioners learned and (optionally) applied using <a href="#StatsAPI.fit!"><code>fit!</code></a>. It can be  subsequently applied on other data as it has been learnt  using the <a href="#DataFrames.transform!"><code>transform!</code></a> function.</p><p>All <code>fit!</code> methods return a pipeline.</p><p>Pipelines comprising a single conditioner are allowed.</p><p>Pipelines can be saved to a file using the <a href="../tools/#PosDefManifoldML.saveas"><code>saveas</code></a> function and loaded from a file using the <a href="../tools/#PosDefManifoldML.load"><code>load</code></a> function.</p><p>Note that in Julia tuples are immutable, thus it is not possible to modify a pipeline. However it is possible to change the fields of the conditioners  it holds.</p><p>In order to create a pipeline use the <a href="#PosDefManifoldML.@pipeline"><code>@pipeline</code></a> macro.</p><p><strong>See also</strong>: <a href="#StatsAPI.fit!"><code>fit!</code></a>, <a href="#DataFrames.transform!"><code>transform!</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifoldML.@pipeline" href="#PosDefManifoldML.@pipeline"><code>PosDefManifoldML.@pipeline</code></a> ‚Äî <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">macro pipeline(args...)</code></pre><p>Create a <a href="#PosDefManifoldML.Pipeline"><code>Pipeline</code></a> chaining the provided expressions.</p><p>As an example, the syntax is:</p><pre><code class="language-julia hljs">p = @pipeline Recenter() ‚Üí Compress ‚Üí Shrink(Fisher; threaded=false)</code></pre><p>Note that:</p><ul><li><p>The symbol ‚Üí (escape &quot;\to&quot;) separating the conditioners is optional.</p></li><li><p>This macro has alias <code>@‚Üí</code>. </p></li><li><p>As in the example above, expressions may be instantiated conditioners, like <code>Recenter()</code>, or their type, like <code>Compress</code>, in which case the default conditioner of that type is created.</p></li></ul><p>The example above is thus equivalent to</p><pre><code class="language-julia hljs">    p = @‚Üí Recenter() Compress() Shrink(Fisher; threaded=false)</code></pre><p>Conditioners are not callable by the macro. Thus if you want to pass a variable, do not write</p><pre><code class="language-julia hljs">    R = Recenter()
    p = @‚Üí R</code></pre><p>but </p><pre><code class="language-julia hljs">    R = Recenter()
    p = @‚Üí eval(R)</code></pre><p><strong>Available conditioners to form pipelines</strong></p><p><a href="#PosDefManifoldML.Tikhonov"><code>Tikhonov</code></a>, <a href="#PosDefManifoldML.Recenter"><code>Recenter</code></a>, <a href="#PosDefManifoldML.Compress"><code>Compress</code></a>, <a href="#PosDefManifoldML.Equalize"><code>Equalize</code></a>, <a href="#PosDefManifoldML.Shrink"><code>Shrink</code></a></p><p><strong>See also</strong>: <a href="#StatsAPI.fit!"><code>fit!</code></a>, <a href="#DataFrames.transform!"><code>transform!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifoldML, PosDefManifold

P=randP(3, 5)
pipeline = fit!(P, @‚Üí Recenter ‚Üí Compress)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StatsAPI.fit!" href="#StatsAPI.fit!"><code>StatsAPI.fit!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    function fit!(ùêè :: ‚ÑçVector, pipeline :: Union{Pipeline, Conditioner}; 
        transform = true,
        labels = nothing)</code></pre><p>Fit the given <a href="#PosDefManifoldML.Pipeline"><code>Pipeline</code></a> (or a single <code>Conditioner</code>) to <span>$ùêè$</span> and return  a fitted <code>Pipeline</code> object. <span>$ùêè$</span> must be of <a href="../MainModule/#the-‚ÑçVector-type">the ‚ÑçVector type</a>.</p><p>A single <code>Conditioner</code> can be given as argument instead of a pipeline; a fitted pipeline with a single element will be returned. The type of the conditioner can be gives as well, in which case the default conditioner will be used - see examples below.</p><p>If <code>pipeline</code> in an empty tuple, return an empty pipeline without doing anything.</p><p>if <code>transform</code> is true (default), <span>$ùêè$</span> is transformed (in-place), otherwise the pipeline is fitted but <span>$ùêè$</span> is not transformed.</p><p>If <code>labels</code> is a vector of integers holding the class labels of the points  in <span>$ùêè$</span>, the conditioners are supervised (<em>i.e.</em>, labels-aware),  otherwise, if it is <code>nothing</code> (default), they are unsupervised.  Currently the only conditioners that can behave in a supervised manner is <a href="#PosDefManifoldML.Recenter"><code>Recenter</code></a>. When supervised, the barycenter for recentering is computed given balanced weights to each class, like <a href="../tools/#PosDefManifoldML.tsWeights"><code>tsWeights</code></a> does for computing the barycenter used for tangent space mapping. If the classes are balanced, the weighting has no effect.</p><p>The returned pipeline can be used as argument for the  <a href="#DataFrames.transform!"><code>transform!</code></a> function, ensuring that the fitted parameters are properly applied. It can also be saved to a file using the <a href="../tools/#PosDefManifoldML.saveas"><code>saveas</code></a> function and loaded from a file using the <a href="../tools/#PosDefManifoldML.load"><code>load</code></a> function.</p><p>Note that the pipeline given as argument is not modified.</p><p><strong>Learning parameters during fit</strong></p><p>For some of the conditioners there is no parameter to be learnt during training.  For those, a call to the <code>fit!</code> function is equivalent to a call to the <a href="#DataFrames.transform!"><code>transform!</code></a> function, with the exception that when the <code>fit!</code> function is called the parameters used for the tranformation are stored in the returned pipeline.</p><p><strong>See also</strong>: <a href="#DataFrames.transform!"><code>transform!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifoldML, PosDefManifold

## Example 1 (single conditioner): 

# Generate some data
P=randP(3, 5) # 5 random 3x3 Hermitian matrices
Q=copy(P)

# Fit the default recentering conditioner (whitening)
pipeline = fit!(P, Recenter) 

# This is equivalent to
pipeline = fit!(Q, Recenter())

pipeline[1].Z # a learnt parameter (whitening matrix)

## Example 2 (pipeline): 

# Fit a pipeline comprising Tikhonov regularization, 
# recentering, compressing and shrinking according to the Fisher metric.
# The matrices in P will be first regularized, then recentered, 
# then compressed and finally shrunk.

P=randP(3, 5)  
Q=copy(P)

pipeline = fit!(P, 
        @‚Üí Tikhonov(0.01) ‚Üí Recenter ‚Üí Compress ‚Üí Shrink(Fisher; radius=0.01))

# or 
pipeline = fit!(Q, @‚Üí Tikhonov(0.01) Recenter Compress Shrink(Fisher; radius=0.01))

# Retrive the amount of Tikhonov regularization that has been applied,
pipeline[1].Œ±

# the whitening matrices of the recentering conditioner,
pipeline[2].Z

# the scaling factors of the compressing conditioner,
pipeline[3].Œ≤

# and the step-size of the shrinking conditioner.
pipeline[4].Œ≥

## Example 3 (pipeline with a single conditioner):
P=randP(3, 5)  
pipeline = fit!(P, @‚Üí Recenter)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DataFrames.transform!" href="#DataFrames.transform!"><code>DataFrames.transform!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function transform!(ùêê :: Union{‚ÑçVector, ‚Ñç}, pipeline :: Union{Pipeline, Conditioner})
</code></pre><p>Given a fitted <a href="#PosDefManifoldML.Pipeline"><code>Pipeline</code></a> (or a single <code>Conditioner</code>), transform all matrices  in <span>$ùêê$</span> using the parameters learnt during the fitting process. Return <span>$ùêê$</span>.</p><p>In a training-test setting, a fitted conditioner or pipeline is given as argument  to this function to make sure that the testing data is transformed according to  the parameters learnt during the fitting of training data. More in general, this function can be used to transform in whatever way the data in <span>$ùêê$</span>.</p><p>If <code>pipeline</code> in an empty tuple, return <span>$ùêê$</span> without doing anything.</p><p><span>$ùêê$</span> can be a single Hermitian matrix or a vector of <a href="../MainModule/#the-‚ÑçVector-type">the ‚ÑçVector type</a>. It is transformed in-place.</p><div class="admonition is-warning" id="Dimension-34700094dbb070b9"><header class="admonition-header">Dimension<a class="admonition-anchor" href="#Dimension-34700094dbb070b9" title="Permalink"></a></header><div class="admonition-body"><p>The dimension of matrix(ces) in <span>$ùêê$</span> must be the same of the dimension of the matrices  used to fit the conditioner or pipeline.</p></div></div><p>In contrast to the <code>fit!</code> function, only instantiated conditioner can be used. For general use, this is transparent to the user as the <a href="#StatsAPI.fit!"><code>fit!</code></a> function always returns pipelines with instantiated conditioners.</p><p><strong>See</strong>: <a href="#StatsAPI.fit!"><code>fit!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifoldML, PosDefManifold

## Example 1 (single conditioner)

# Generate some &#39;training&#39; and &#39;testing&#39; data
PTr=randP(3, 20) # 20 random 3x3 Hermitian matrices
PTe=randP(3, 5) # 5 random 3x3 Hermitian matrices

# Fit the default recentering conditioner (whitening)
# Matrices in PTr will be transformed (recentered)
R = fit!(PTr, Recenter()) 

# Transform PTe using recentering as above
# using the parameters for recentering learnt
# on PTr during the fitting process. 
transform!(PTe, R)

mean(PTr)-I # Should be close to the zero matrix.
mean(PTe)-I # Should not be close to the zero matrix
# as the recentering parameter is learnt on PTr, not on PTe.

## Example 2 (pipeline)

# Generate some &#39;training&#39; and &#39;testing&#39; data
PTr=randP(3, 20) # 20 random 3x3 Hermitian matrices
PTe=randP(3, 5) # 5 random 3x3 Hermitian matrices
QTr=copy(PTr)
QTe=copy(PTe)

p = @‚Üí Tikhonov(0.0002) Recenter(; eVar=0.99) Compress Shrink(Fisher; radius=0.01)
pipeline = fit!(QTr, p)
transform!(QTe, pipeline)

## Example 3 (pipeline with a single conditioner):
P=randP(3, 5)  
# For the Equalize conditioner there is no need to fit some data
transform!(P, @‚Üí Equalize)
# This gives an error as Recenter needs to learn parameters (use fit! instead):
transform!(P, @‚Üí Recenter)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifoldML.pickfirst" href="#PosDefManifoldML.pickfirst"><code>PosDefManifoldML.pickfirst</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function pickfirst(pipeline, conditioner)</code></pre><p>Return a copy of the first conditioner of the <code>pipeline</code> which is of  the same type as <code>conditioner</code>. If no such conditioner is found, return <code>nothing</code>. Note that a copy is returned, not the conditioner in the pipeline itself.</p><p>The provided <code>conditioner</code> can be a type or an instance of a conditioner. The returned element will always be an instance, as pipelines holds instances only.</p><p><strong>See</strong>: <a href="#PosDefManifoldML.includes"><code>includes</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifoldML

pipeline = @‚Üí Recenter() Shrink()
S = pickfirst(pipeline, Shrink) 
S isa Conditioner # true
S isa Shrink # true

# retrive a parameter of the conditioner
pickfirst(pipeline, Shrink).radius
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifoldML.includes" href="#PosDefManifoldML.includes"><code>PosDefManifoldML.includes</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function includes(pipeline, conditioner)</code></pre><p>Return true if the given <a href="#PosDefManifoldML.Pipeline"><code>Pipeline</code></a> includes a conditioner  of the same type as <code>conditioner</code>.</p><p>The provided <code>conditioner</code> can be a type or an instance of a conditioner.</p><p><strong>See</strong>: <a href="#PosDefManifoldML.pickfirst"><code>pickfirst</code></a>, <a href="#PosDefManifoldML.@pipeline"><code>@pipeline</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifoldML

pipeline= @‚Üí Recenter() ‚Üí Shrink()

includes(pipeline, Shrink) # true

includes(pipeline, Shrink()) # true

# same type, although a different instance
includes(pipeline, Shrink(Fisher; radius=0.1)) # true

includes(pipeline, Compress) # false</code></pre><p><strong>Learn the package</strong>: check out <a href="../tools/#PosDefManifoldML.saveas"><code>saveas</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PosDefManifold.dim" href="#PosDefManifold.dim"><code>PosDefManifold.dim</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function dim(pipeline::Pipeline)</code></pre><p>Return the dimension determined by a fitted <a href="#PosDefManifoldML.Recenter"><code>Recenter</code></a> pre-conditioner  if the <code>pipeline</code> comprises such a pre-conditioner, <code>nothing</code> otherwise. </p><p>This is used to adapt pipelines - see the documentation of the <a href="#StatsAPI.fit!"><code>fit!</code></a> function for ENLR machine learning models for an example.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using PosDefManifoldML, PosDefManifold

pipeline = @‚Üí Recenter(; eVar=0.9) ‚Üí Shrink()
dim(pipeline) # return `nothing`, as it is not fitted

P = randP(10, 5)
p = fit!(P, pipeline)
dim(p) # return an integer ‚â§ 10</code></pre><p><strong>Learn the package</strong>: check out <a href="#PosDefManifoldML.@pipeline"><code>@pipeline</code></a></p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../stats_inferential/">¬´ Inferential</a><a class="docs-footer-nextpage" href="../contribute/">How to contribute ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Wednesday 24 December 2025 16:31">Wednesday 24 December 2025</span>. Using Julia version 1.11.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
